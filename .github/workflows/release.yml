# Automated Release Workflow
#
# This workflow automatically manages versioning and releases based on commit messages.
# It uses Conventional Commits to determine the version bump type.
#
# REQUIRED SECRET:
# - PAT_TOKEN: Personal Access Token with 'repo' and 'pull_requests' scopes
#   Create at: https://github.com/settings/tokens/new
#   Add to repo secrets at: https://github.com/hope0hermes/StravaFetcher/settings/secrets/actions
#
# When it runs:
# - Automatically: When a PR is merged to main (via "push: branches: [main]")
# - Manually: Via GitHub Actions UI (workflow_dispatch button)
#
# What it does:
# 1. Analyzes commit messages since last release
# 2. Determines version bump type (major/minor/patch/none)
# 3. Updates version in src/strava_fetcher/__init__.py using hatch
# 4. Updates CHANGELOG.md with new version and commit list
# 5. Creates a PR with version bump changes
# 6. After PR is merged, create-release.yml automatically creates the GitHub Release
#
# Conventional Commit Format → Version Bump:
# - "feat:" or "feature:" → MINOR bump (1.0.0 → 1.1.0) - New features
# - "fix:" or "bugfix:" → PATCH bump (1.0.0 → 1.0.1) - Bug fixes
# - "feat!:" or "BREAKING CHANGE:" → MAJOR bump (1.0.0 → 2.0.0) - Breaking changes
# - "chore:", "docs:", "ci:", "style:", "test:" → NO bump - No user-facing changes
#
# Version Management:
# - Version stored in: src/strava_fetcher/__init__.py (__version__ = "1.0.0")
# - Hatch reads/writes version automatically (configured in pyproject.toml)
# - Single source of truth prevents version conflicts

name: Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allows manual triggering from GitHub UI

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write        # Required to push commits and create releases
      pull-requests: write   # Required if you want to comment on PRs

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history so we can find previous tags
        token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install hatch  # Needed for "hatch version" command

    - name: Configure Git
      run: |
        # Set git identity for the version bump commit
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: Check if should skip
      id: should_skip
      run: |
        COMMIT_MSG=$(git log -1 --pretty=format:"%s")
        echo "Last commit: $COMMIT_MSG"

        # Skip if:
        # 1. Commit contains [skip ci]
        # 2. Commit message starts with "chore: bump version"
        # 3. Commit is a merge from a release/ branch (version bump PR merge)
        if echo "$COMMIT_MSG" | grep -qE "\[skip ci\]|^chore: bump version|^Merge pull request .* from .*/release/"; then
          echo "should_skip=true" >> $GITHUB_OUTPUT
          echo "Skipping release workflow (version bump or [skip ci] commit)"
        else
          echo "should_skip=false" >> $GITHUB_OUTPUT
          echo "Proceeding with release workflow"
        fi

    - name: Determine version bump type
      if: steps.should_skip.outputs.should_skip != 'true'
      id: bump_type
      run: |
        # Get all commit messages since last tag (or all commits if no tags)
        if git describe --tags --abbrev=0 2>/dev/null; then
          LAST_TAG=$(git describe --tags --abbrev=0)
          COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s")
        else
          COMMITS=$(git log --pretty=format:"%s")
        fi

        echo "Commits: $COMMITS"

        # Analyze commits using regex patterns for Conventional Commits
        # Priority: major > minor > patch > none (if any commit is major, bump major)
        # Note: GitHub adds (#PR) to merge commits, so we check for ! anywhere before :
        if echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?!|BREAKING CHANGE:"; then
          BUMP="major"  # Breaking changes: 1.0.0 → 2.0.0
        elif echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?:"; then
          BUMP="minor"  # New features: 1.0.0 → 1.1.0
        elif echo "$COMMITS" | grep -qE "^(fix|bugfix|perf|refactor)(\(.+\))?:"; then
          BUMP="patch"  # Bug fixes: 1.0.0 → 1.0.1
        else
          BUMP="none"   # No version bump (chore, docs, ci, etc.)
        fi

        # Save bump type to GitHub Actions output for use in later steps
        echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
        echo "Determined bump type: $BUMP"

    - name: Bump version
      if: steps.should_skip.outputs.should_skip != 'true' && steps.bump_type.outputs.bump_type != 'none'
      id: version
      run: |
        # Get current version
        OLD_VERSION=$(hatch version)

        # Bump version using hatch (automatically updates __init__.py)
        hatch version ${{ steps.bump_type.outputs.bump_type }}

        # Get new version and save to outputs
        NEW_VERSION=$(hatch version)
        echo "old_version=$OLD_VERSION" >> $GITHUB_OUTPUT
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "Bumped version from $OLD_VERSION to $NEW_VERSION"

    - name: Update CHANGELOG
      if: steps.should_skip.outputs.should_skip != 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"
        DATE=$(date +%Y-%m-%d)

        # Get commits since last tag for changelog (excluding merge commits)
        if git describe --tags --abbrev=0 2>/dev/null; then
          LAST_TAG=$(git describe --tags --abbrev=0)
          COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
        else
          COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
        fi

        # Insert new version section after [Unreleased] header
        # Use a temporary file to build the new changelog
        {
          sed -n '1,/^## \[Unreleased\]/p' CHANGELOG.md
          echo ""
          echo "## [$NEW_VERSION] - $DATE"
          echo ""
          echo "### Changed"
          echo "$COMMITS"
          echo ""
          sed -n '/^## \[Unreleased\]/,$p' CHANGELOG.md | tail -n +2
        } > CHANGELOG.md.tmp
        mv CHANGELOG.md.tmp CHANGELOG.md

        echo "Updated CHANGELOG.md"

    - name: Create version bump PR
      if: steps.should_skip.outputs.should_skip != 'true' && steps.bump_type.outputs.bump_type != 'none'
      run: |
        BRANCH_NAME="release/v${{ steps.version.outputs.new_version }}"

        # Create and checkout new branch
        git checkout -b "$BRANCH_NAME"

        # Commit changes
        git add src/strava_fetcher/__init__.py CHANGELOG.md
        git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }}"

        # Push branch
        git push origin "$BRANCH_NAME"

        # Create PR body
        PR_BODY="Automated version bump to ${{ steps.version.outputs.new_version }}

        This PR was automatically created by the release workflow.

        **Changes:**
        - Updated version in src/strava_fetcher/__init__.py
        - Updated CHANGELOG.md with release notes

        **Note:** After merging this PR, the GitHub Release will be automatically created by the create-release workflow."

        # Create PR using gh CLI
        gh pr create \
          --title "chore: bump version to ${{ steps.version.outputs.new_version }}" \
          --body "$PR_BODY" \
          --base main \
          --head "$BRANCH_NAME"

        # Trigger checks on the PR by creating an empty commit
        # This ensures checks run and appear as required status checks
        git commit --allow-empty -m "chore: trigger CI checks"
        git push origin "$BRANCH_NAME"
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}